### 项目起步

#### Angular
通过cli工具搭建

#### React
通过cli工具搭建也可通过直接引入script脚本

#### Vue
通过cli工具搭建也可通过直接引入script脚本

### 启动方式

#### Angular
```js
@NgModule({
  declarations: [Demo],
  imports: [BrowserModule],
  bootstrap: [Demo]
})
export class AppModule { }

platformBrowser().bootstrapModule(AppModule);
```

#### React
```js
ReactDOM.render(<Demo/>, document.getElementById('root'))
```

#### Vue
```js
new Vue({
  render: h => h(Demo)
}).$mount('#root')
```

### 语法提示/错误检查

#### Angular
框架本身的强约束性和语法严谨性保证，项目工程维护效率极高，报错信息大部分可以精准到代码行，而且是构建时进行错误检查（非运行时），和IDE集成甚至可以实现编译前进行错误检查，打包上线前也会进行错误检查，降低了低级Bug流入线上的可能

#### React
本身极高灵活性导致排查问题难度很高，很多时候只有在运行某个组件时才能发现错误，而且报错信息有时很模糊，难以定位，为了稍微弥补一下这方面短板，调试环境下报错信息是直接展示在页面上的，点击报错信息可以直接切换到IDE中指定源码行

#### Vue
本身高灵活性导致排查问题难度较高，很多时候只有在运行某个组件时才能发现错误，而且报错信息有时很模糊，难以定位


### 数据与UI同步

#### Angular
通过 `zone.js` 尽量拦截常见的异步操作：UI事件，Ajax请求，setTimeout等，而这些异步操作绝大部分情况都会伴随数据改变，在异步操作完成之后统一进行数据同步，使用启发式同步，引入副作用，在Angular环境中使用第三方库需要避免由于事件触发无意义的赃值检查，多使用NgZone.runOutsideAngular

react不能直接修改state，而且setState更新有时是异步的（生命周期内，事件处理函数），像 `setTimeout` 回掉函数则是同步更新state，整体数据UI同步方式太笨拙繁琐，但也为精确UI控制带来可能

#### React
显式通过setState更改数据并主动告知需要进行数据同步，React会在合适时机进行UI同步

#### Vue
通过 `Object.defineProperty` 包装数据对象的所有属性，get 属性调用时收集依赖，set 属性调用时自动进行UI同步，引入副作用，操作数组的注意事项：

- 无法跟踪，利用索引直接设置一个数组项
- 无法跟踪，修改数组的长度
```js
// 错误
vm.items[indexOfItem] = newValue   
// 正确
Vue.set(vm.items, indexOfItem, newValue) 或者 vm.items.splice(indexOfItem, 1, newValue)
// 错误
vm.items.length = newLength   
// 正确
vm.items.splice(newLength)
// 错误
Object.assign(vm.userProfile, { 
age: 27, favoriteColor: 'Vue Green'
 })
// 正确
vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: 'Vue Green' 
})
```

### UI相关的数据如何管理

#### Angular
基于类的编程方式，UI相关的数据直接作为类的属性进行管理，属性命名没有任何要求

#### React
基于类的编程方式，UI相关的数据需要统一保存在state属性中，更改state需要通过setState方法

state中的数据依赖另一个state中的数据时需要通过setState回掉函数的方式实现

#### Vue
基于配置对象的编程方式，UI相关的所有数据需要提前在data方法中定义并返回，属性命名没有任何要求

#### 点评
在这方面约束和侵入性比较：React > Vue > Angular，UI数据辨识性：React > Angular = Vue

### UI和逻辑代码组织方式

#### Angular
UI和逻辑代码尽量划分界限

#### React
通过JSX尽量将UI和逻辑代码混合在一起

#### Vue
UI和逻辑代码尽量划分界限

### 文件如何组织

#### Angular
通过模块概念组织文件

#### React
没有规定

#### Vue
没有规定



### 数据绑定/显示

#### Angular
```html
<a [href]="link">{{content}}</a>
<a href="http://{{link}}">{{content}}</a>
<demo [(value)]="val"></demo>
```
元素属性也可以使用插值表达式

#### React
```html
<a href={this.state.link}>{this.state.content}</a>
<Demo value={this.state.val} onUpdate={(val) => this.setState({val})}/>
```
- 双引号和{}不能同时出现在一个属性赋值中
- 元素属性是大小写敏感的，而且需要转为驼峰命名，例如tabindex转为tabIndex
- 元素class属性需要替换为className
- 元素innerHtml属性需要替换为dangerouslySetInnerHTML
- 元素for属性需要替换为htmlFor

#### Vue
```html
<a :href="link">{{content}}</a>
<demo :value.sync="val"></demo>
```

### 条件渲染

#### Angular
```html
<button *ngIf="showBtnType === 'del'">删除</button>
<button *ngIf="showBtnType === 'add'">添加</button>
<button *ngIf="!showBtnType">查看</button>
```

#### React
```html
// 三元表达式
{this.state.showDelBtn ? <button>删除</button> : null}
// &&运算符
{this.state.showDelBtn && <button>删除</button>}
使用&&时需要注意符号左边表达式返回值不能为数字，否则当值为0时，在页面上将会显示0
// 单独if块，不推荐弱化条件渲染，提供阅读代码的复杂度
render() {
  let ele;
  if(this.state.showDelBtn){
    ele = <button>删除</button>
  }else if(this.state.showAddBtn){
    ele = <button>添加</button>
  }else{
    ele = <button>查看</button>
  }

  return ele;
}
```

#### Vue
```html
<button v-if="showDelBtn">删除</button>
<button v-else-if="showAddBtn">添加</button>
<button v-else>查看</button>
```
元素之间不能存在其他元素

### 列表渲染

#### Angular
```html
<ul >
  <li *ngFor="let item of list;let index = index;trackBy: byId">{{index}} --- {{item.name}}</li>
</ul>

<ul>
  <ng-container *ngFor="let item of list;let index = index;trackBy: byId">
    <li>index: {{index}}</li>
    <li>{{item.name}}</li>
  </ng-container>
</ul>

byId(index,item){
  return item.id
}
```
- 单次遍历输出多个节点需要将多节点包裹在`ng-container`中
- `trackBy` 写法太繁琐，而且官方团队对此无动于衷

#### React
```html
<ul>
  {this.state.list.map((item, index) => {
    return <li key={item.id}>{index} --- {item.name}</li>;
  })}
</ul>

<ul>
  {this.state.list.map((item, index) => {
    return [
      <li key={'index' + item.id}>index: {index}</li>,
      <li key={item.id}>{item.name}</li>
    ];
  })}
</ul>
```
- 单次遍历输出多个节点不需要类似 `ng-container` 
- 列表渲染必须有key

#### Vue
```html
<ul>
  <template v-for="(item,index) of list">
    <li href :key="'index' + item.id">index: {{index}}</li>
    <li href :key="item.id">{{item.name}}</li>
  </template>
</ul>
```
- 单次遍历输出多个节点需要将多节点包裹在 `template`中
- 列表渲染必须有key

### 事件处理

#### Angular
```html
<button (click)="run($event)">点击</button>
```
无法注册捕获阶段的事件处理函数

#### React
```html
<button onClick="this.run.bind(this,e)">点击</button>
或者
class Demo extends React.Component {
  run = () => { }
}
<button onClick="this.run">点击</button>
或者
<button onClick={(e) => this.run(e) } onClickCapture={(e) => this.run(e)}>点击</button>
```
事件处理函数需要处理好 `this` 指向问题，根本原因还是因为jsx太灵活，jsx中变量范围比模版范围广，React没法固定事件回调函数this

给组件添加事件处理函数本质是一个属性赋值的行为，不能执行语句，这一点和Angular/Vue不太一样

SyntheticEvent 是合并而来。这意味着 SyntheticEvent 对象可能会被重用，而且在事件回调函数被调用后，所有的属性都会无效。出于性能考虑，你不能通过异步访问事件，在事件上调用 event.persist()，此方法会从池中移除合成事件，允许用户代码保留对事件的引用

在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理）或者执行生命周期函数，调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，包括绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用，setState会同步更新this.state

事件处理函数如果需要接收额外参数：
```html
<button onClick="this.run.bind(this, param1, param2)">
或者
<button onClick={() => this.run(param1, param2) }>点击</button>
或者
<button data-msg={params} onClick={this.onChange}
this.onChange = (e)=> {
  e.target.dataset.msg
}
```

#### Vue
```html
<button @click.capture="run()">点击</button>
或者
<button @click="run">点击</button>
```
语法定义很模糊

### 表单处理

#### Angular
```html
<input [(ngModel)]="searchText">
```

#### React
```html
<input value={this.state.searchText} onChange={this.searchTextChange.bind(this)}>

searchTextChange(e) {
  this.setState({searchText: e.target.value})
}
```
- 写法太繁琐，如果是多个表单更繁琐，而且要直接操作和读取原生DOM
- 表单系统是一个无法切割耦合性api设计，完全属于黑盒行为
- 在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null
- 非受控表单元素需要通过defaultValue才能设置input和textarea默认值
- input元素type为checkbox或者radio时，通过defaultChecked设置默认选中状态
- 重写表单元素change事件默认行为

#### Vue
```html
<input v-model="searchText">
```

### 组件定义

#### Angular
```js
@Component({
  selector: 'demo',
  template: '<h2>{{text}}</h2>'
})
class Demo {
  text = 'hello'
}
```

#### React
```js
class Demo extends React.Component {
  state = {
    text: 'hello'
  }

  render(){
    return (
      <h2>{this.state.text}</h2>
    )
  }
}
```
- 组件名在使用时必须为大写开头
- 组件定义时的名称和使用时可以不一致
- 非函数组件需要继承 `React.Component`，无法很好的引入类继承机制实现业务组件的逻辑复用

#### Vue
```js
Vue.extend({
  template: '<h2>{{text}}</h2>',
  data: function() {
    return {
      text: 'hello'
    }
  }
})
```
组件定义时的名称和使用时可以不一致

#### 点评
因为React/Vue使用组件时的名称和组件定义时没有强关联所以可维护性较弱，另外React使用组件时名称必须大写开头，否则会识别为普通标签，这样规定太过强硬，反观Angular组件定义和使用时是强关联一定程度提高维护性，另外组件名可以是大部分合法的css选择器，又可灵活扩展组件应用范围

当组件中使用多个其它组件时，React需要一个个的导入对应组件，或者通过组件名 + 点语法，Vue需要在components中声明使用到的组件，或者把使用到的组件定位为全局组件，而Angular通过模块统一处理组件导入，使用时不需要关心细节

### 组件输入属性

#### Angular
```js
@Component({
  template: '<h2>{{text}}</h2>'
})
class Demo {
  @Input() text = 'hello'
}
```
- 利用ts类型推导，text被自动识别为String类型
- 在使用组件时如果传入组件未定义输入属性，在编译时会提示错误
- 静态输入属性在DOM树中完整展示，动态输入属性以 `ng-reflect-[属性名]="[属性类型]"` 展示
- 如果输入属性没有赋值，组件内获取到的值为空字符串

#### React
```js
class Demo extends React.Component {

  render() {
    return (<h2>{this.props.text}</h2>)
  }

  static defaultProps = {text: 'hello'};

  static propTypes = {
    text: PropTypes.string
  };
}
```
- 输入属性是只读的不能再组件内修改
- 在使用组件时如果传入组件未定义输入属性，没有任何提示错误
- 如果输入属性没有赋值，组件内获取到的值为 `true`
- `key` `ref` 是特殊属性，会传递信息给 React ，但不会传递给你的组件。应避免使用使用特殊属性作为输入属性

#### Vue
```js
Vue.extend({
  template: '<h2>{{text}}</h2>',
  props: {
    text: {
      type: String,
      default: 'hello'
    }
  }
})
```
- 输入属性是只读的不能再组件内修改
- 如果props默认值是对象，default必须是一个函数
- 在使用组件时如果传入组件未定义输入属性，没有任何提示错误
- 如果输入属性没有赋值，组件内获取到的值为空字符串

#### 点评
Angular通过装饰器明确标注哪些类属性为组件输入属性，提高代码可读性，同时可以让外部感知到组件有哪些输入属性，而React，Vue这方面相对不够友好，属性默认值写法也很繁琐

### 组件事件处理

#### Angular
```js
class Demo {
  @Output() textChange = new EventEmitter();

  updateTextChange() {
    this.textChange.emit('world')
  }
}
```

#### React
```js
class Demo extends React.Component {
  updateTextChange() {
    this.props.textChange('world')
  }
}
```

#### Vue
```js
Vue.extend({
  methods: {
    updateTextChange() {
      this.$emit('textChange','world')
    }
  }
})
```

#### 点评
React/Vue 书写的组件通常不在意事件定义，如果需要了解一个组件对外暴露那些事件，需要通读整个组件代码，当然 Vue可以通过自定义prop来描述事件，React可以通过propTypes描述事件属性，在这方面Angular表现比较自然

### 同时指定多个属性给组件

#### Angular
```html
<demo prop1="prop1" prop2="prop2" prop3="prop3" otherProp="prop"></demo>
```

#### React
```html
<Demo {...props} otherProp={prop}/>
```

#### Vue
```html
<Demo v-bind="props" :otherProp="prop">
```

### 一次Dom更新而渲染未开始时执行回掉函数

#### Angular
订阅NgZone实例的onStable属性

#### React
生命周期方法 getSnapShotBeforeUpdate

#### Vue
组件实例内置方法$nextTick


### 动态html安全

#### Angular

### Dom渲染时组件本身是否存在Dom树中

#### Angular
存在，尽量贴近Web Component

#### React
不存在

#### Vue
不存在

### 组件根元素

#### Angular
组件根元素没有任何约束，尽量贴近Web Component

#### React
不能存在多个根元素，但可以通过<React.Fragment>间接实现(可以简写为<>...</>)，或者
```js
render() {
  return [
    <li key="a">...</li>,
    <li key="b">...</li>,
    <li key="c">...</li>,
    <li key="d">...</li>
    ...
  ]
}
// key必须存在
```
优点是可以实现灵活的元素嵌套：table > tr > component > td

#### Vue
必须只有一个根元素，原因是虚拟Dom的Diff算法导致的，如果改成支持多个根元素需要重写现有Diff算法得不偿失



### 获取组件实例/原生DOM

#### Angular
```html
<input #ele>
<demo #com></demo>

@ViewChild('ele') eleRef;
@ViewChild('com') instance;
@ViewChild('com', { read: ElementRef }) comEleRef;

ngAfterViewInit(): void {
  console.log(this.eleRef.nativeElement.tagName);
  console.log(this.instance);
  console.log(this.comEleRef.nativeElement.tagName);
}
```

#### React
```js
componentDidMount() {
  console.log(this.eleRef.tagName);
  console.log(this.instance);
}

render() {
  return (
    <>
      <input ref={(ele) => this.eleRef = ele} />
      <Demo ref={(instance) => this.instance = instance} />
    </>
  )
}

// 或者

constructor(props){
  super(props);
  this.eleRef = React.createRef();
  this.instance = React.createRef();
}

componentDidMount() {
  console.log(this.eleRef.current.tagName);
  console.log(this.instance.current);
}

render() {
  return (
    <>
      <input ref={this.eleRef} />
      <Demo ref={this.instance} />
    </>
  )
}
```
如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题

可以通过React.forwardRef将组件内的Dom暴露到组件外部

#### Vue
```html
<input ref="ele">
<demo ref="com"></demo>

mounted: function() {
  console.log(this.$refs.ele.tagName);
  console.log(this.$refs.com)
}
```

### 插槽

#### Angular
```html
组件外部使用
<demo>
  <h1 class="view" #slot1>aaa</h1>
  <h2 #slot2>bbb</h2>
  <ng-template #slot3 let-msg="message" let-self>
    <h3>{{msg}} --- {{self}}</h3>
  </ng-template>
  <h4 >ddd</h4>
  <h5 >eee</h5>
</demo>

demo组件内
<ng-content select=".view"></ng-content>
<ng-content select="h2"></ng-content>
<ng-container *ngTemplateOutlet="slot3; context: slotContext"></ng-container>
<ng-content></ng-content>

demo组件内获取插槽
@ContentChild('slot1') slot1: ElementRef;
@ContentChild('slot2') slot2: ElementRef;
@ContentChild('slot3') slot3: TemplateRef<any>;
slotContext = { message: 'ccc', $implicit: 'xxx' };

```
插槽无法设置后备内容，写法有些繁琐

#### React
```html
组件外部使用
render(){
  const slot1 = <h1 className="view" >aaa</h1>
  const slot2 = <h2 >bbb</h2>
  const slot3 = (msg) => (<h3 >{msg}</h3>)

  return (<Demo {...{slot1,slot2,slot3}}>
    <h4>ddd</h4>
    <h5>eee</h5>
  </Demo>);
}

Demo组件内
state = {
  message: 'ccc'
}

render(){
  return (
    <>
      {this.props.slot1}
      {this.props.slot2}
      {this.props.slot3(this.state.message)}
      {this.props.children}
    </>
  );
}
```
- 无法直接获取dom对象

#### Vue
```html
组件外部使用
<Demo>
  <!-- 简写形式 <template #slot1> -->
  <template v-slot:slot1>
    <h1 class="view">aaa</h1>
  </template>

  <template v-slot:slot2>
    <h2>bbb</h2>
  </template>

<!-- 简写形式 <template #slot3="{message: msg}"> -->
  <template v-slot:slot3="{message: msg}">
    <h3>{{msg}}</h3>
  </template>

  <template v-slot>
    <h4>ddd</h4>
    <h5>eee</h5>
  </template>
</Demo>

Welcome组件内
<div>
  <slot name="slot1" />
  <slot name="slot2" />
  <slot name="slot3" :message="'ccc'" />
  <slot />
</div>

demo组件内获取插槽
this.$slots.h1
this.$slots.h2
this.$slots.h3
```
写法有些繁琐

支持动态插槽名 v-slot:[dynamicSlotName]，如果只有默认插槽可以进一步简化：
```html
<!-- 简写形式 <Demo #default="{message: msg}"> -->
<Demo v-slot="{message: msg}">
  <h3>{{msg}}</h3>
</Demo>
```

### 组件树全局状态管理

#### Angular


#### React


#### Vue

### 异常处理

#### Angular
```ts
class MyErrorHandler implements ErrorHandler{
  handleError(e){
    ...
  }
}

@NgModule({
  providers: [
    {provide: ErrorHandler, useClass: MyErrorHandler}
  ]
})
```
可以捕获组件生命周期函数，事件处理函数，异步回掉函数(setTime)，ajax请求异常需要单独处理，不能捕获组件类构造函数里面的异常

#### React
```js
class Demo extends React.Component {
  state = {hasError: false}

  componentDidCatch(error, errorInfo){
    // 处理异常
  }

  static getDerivedStateFromError() {
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      return '报错了'
    }

    return (
      <>
        ...
      </>
    )
  }
}
```
可以捕获组件生命周期函数和组件构造函数，不能捕获的异常：事件处理函数，异步回掉函数(setTime)，ajax请求，组件自身。当捕获异常后react会卸载整个组件树

#### Vue
```js
Vue.config.errorHandler = function(error, vm, info){
  // 处理异常
}
```
可以捕获组件生命周期函数，事件处理函数，不能捕获的异常：异步回掉函数(setTime)，ajax请求

### Portal

#### Angular
```ts
let componentFactory = this.componentFactoryResolver.resolveComponentFactory(ComponentType);
let componentRef = viewContainerRef.createComponent(componentFactory);
componentRef.instance
```

#### React
```js
render (){
  return ReactDOM.createPortal(<div>{this.state.text}</div>, document.getElementById('portal'))
}
```

#### Vue
```js
createPortal(){
  new Vue({
    render: (c) => c(PortalComponent)
  }).$mount('#portal')
}
```



### 全局状态管理

### 动态组件

### 异步组件



### 设计范式

### 组件生命周期

### 组件逻辑复用



### 组件间数据通信

### 组件样式

### 模板检查



### 杂项

### CLI功能



### isOpen还是open()

### 虚拟DOM是必须的吗



### React严格模式
- 监测过时或者废弃api
- 尽可能帮助开发者发现有副作用的代码
- 仅在开发模式下运行；它们不会影响生产构建


因为上述方法可能会被多次调用，所以不要在它们内部编写副作用相关的代码，这点非常重要。忽略此规则可能会导致各种问题的产生，包括内存泄漏和或出现无效的应用程序状态。不幸的是，这些问题很难被发现，因为它们通常具有非确定性。

严格模式不能自动检测到你的副作用，但它可以帮助你发现它们，使它们更具确定性。通过故意重复调用以下函数来实现的该操作：

class 组件的 constructor，render 以及 shouldComponentUpdate 方法
class 组件的生命周期方法 getDerivedStateFromProps
函数组件体
状态更新函数 (即 setState 的第一个参数）
函数组件通过使用 useState，useMemo 或者 useReducer
注意：

这仅适用于开发模式。生产模式下生命周期不会被调用两次。