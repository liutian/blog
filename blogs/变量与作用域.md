### let和var区别
- `let` 声明的变量只在命令所在的代码块内有效
```
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1


var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
// 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算
// 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```
- 不存在变量提升，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错
```
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错

typeof x; // ReferenceError
let x;
```
> 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
- 不允许重复声明变量


### 块级作用域
```
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```


### 声明变量的六种方法
`var` `let` `const` `function` `import` `class`


### 顶层对象
在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的  
为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
```
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```
> ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。


### 解构赋值
- 只有等号两边的 **模式** 相同，左边的变量才会被赋予对应的值，当等号右边的值不是对象或数组，将其转为对象在进行赋值
```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let {length} = ['xxx']; // 因为数组也是对象
let {size} = new Map();

let [foo] = 1; // 报错
let [foo] = {}; // 报错

// 由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```
- 只要数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
```
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"

let [a, b, c] = 'xyz';
a // 'x'
b // 'y'
z // 'z'

let map = new Map();
map.push('name','Zhang');
let [list] = map;
list // ['name','Zhang'];

for (let [key, value] of map) {
  // ...
}
// 或者
for (let [,value] of map) {
  // ...
}
```
- 变量名与属性名不一致
```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let arr = ['a','b','c','d'];
let {[10]: ten,[arr.length - 1]: last} = arr;
ten // undefined
last // 'd'
```
- 嵌套赋值
```
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p, p: [x, { y }] } = obj;
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
// 第二个p只是模式的一部分，第一个p才是变量赋值
```
- 给现有对象或者数组赋值
```
let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
```
- 特殊解构赋值默认值
```
let {x: y = 3} = {};
y // 3

let {x: y = 3} = {x: 5};
y // 5

let {0:first = 'aa'} = ['xx','yy'];
```
- 如果要将一个已经声明的变量用于解构赋值，必须非常小心
```
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error

// 正确的写法
let x;
({x} = {x: 1});
```
