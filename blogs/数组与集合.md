### 奇妙的length
当数组成员新增，移除或者最大索引值变化时，数组 `length` 会动态变化，`length` 永远等于数组 `index` + 1，当强制把数组的 `length` 值变小时，数组会自动删除 `index` 大于等于 `length` 的成员
```
let arr = [1,2,3,4,5,6];
arr.length = 3;
arr // [1,2,3]
```


### Array.from
`Array.from` 可以将伪数组和可遍历对象转为真正的数组
> 只有对象中包含 `length` 属性就是伪数组
```
// 伪数组
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}

Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
```
`Array.from` 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组
```
let spans = document.querySelectorAll('span.name');

// Array.from()
let names = Array.from(spans, s => s.textContent)
```


### Array.prototype.includes 与 Array.prototype.indexOf 的区别
`Array.prototype.indexOf` 它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判
```
[NaN].indexOf(NaN)
// -1

[NaN].includes(NaN)
// true
```


### Array.prototype.flat
用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响
```
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```


### Array.prototype.sort() 的排序稳定性
ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定
```
// 正确sort排序，符合预期 straw 在 spork 之前
const arr = [
  'peach',
  'straw',
  'apple',
  'spork'
];

const stableSorting = (s1, s2) => {
  if (s1[0] < s2[0]) return -1;
  return 1;
};

arr.sort(stableSorting)
// ["apple", "peach", "straw", "spork"]
arr.sort(stableSorting)
// ["apple", "peach", "straw", "spork"]


// 错误sort排序，导致不稳定排序结果
const unstableSorting = (s1, s2) => {
  if (s1[0] <= s2[0]) return -1;
  return 1;
};

arr.sort(unstableSorting)
// ["apple", "peach", "spork", "straw"]
arr.sort(unstableSorting)
// ["apple", "peach", "straw", "spork"]
```